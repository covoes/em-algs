function [individual]=split(individual, splitFName, splitOpName, maxKMSIter, maxClusters, data)
%SPLIT Splits a cluster in the individual.
%
%
%splitFName        : name of the function used to assess clusters for splitting. Possible are: 'lkl','kul'
%splitOpName       : name of the split operator to use. Possible are: 'svd', 'var'

%compute mutation probabilities for each cluster using splitFName
%assumes that higher values have more probability to mutate

global DEBUG;

switch(splitFName)
	case 'lkl'
		[posterior gauss] = computePosterior( individual, data );
		%computes the part of each cluster in the likelihood
		%this line computes ln pi_i + ln N(x_i|\theta_j)
		lnTerms = bsxfun(@plus, log(eps+individual.mixCoef(1:individual.numClusters)), log(eps+gauss));
		%transorm in positive so that higher values will have more probability to mutate
		valuesMutationClusters = -1*sum(posterior .* lnTerms, 1);
	case 'kul'
		[posterior gauss] = computePosterior( individual, data );
		%assuming no objects in the same position.. for continuous features this is expected
		localDensity = bsxfun(@rdivide,posterior,sum(posterior, 1));
		%make sure it sums up to 1
		gauss = bsxfun(@rdivide, gauss, sum(gauss,1));
		valuesMutationClusters = localDensity .* log2( localDensity ./ gauss );
		valuesMutationClusters = sum(valuesMutationClusters, 1);		
end

%rank-based linear normalization
[valuesSorted idxSorted] = sort( valuesMutationClusters );
pMutationClusters( idxSorted ) = 1:individual.numClusters;
pMutationClusters = pMutationClusters ./ sum(pMutationClusters);

%perform mutation using splitOpName
switch(splitOpName)
	case 'svd' %Singular Value Decomposition based Splitting
		z = randi([1 individual.numClusters]);
		%pick the clusters that will be mutated
		chosen = roulette_without_reposition( pMutationClusters, z );
		[vals idxClustResp] = max(posterior, [], 2);
		for c=1:z			
			if ((individual.numClusters+1) > maxClusters)
				break;
			end

			%l is the cluster being splitted
			%it gives origin to clusters i and j 
			covL     = squareformSymmetric(individual.covariance( chosen(c), : ));
			meanL    = individual.mean( chosen(c),: );
			mixCoefL = individual.mixCoef( chosen(c) );

			[U S V] = svd( covL );
			A = U*sqrt(S);
			a = A(:,1)';
			%these values are used in the experiments made in Zhang,2003
			alpha = 0.5;
			u = 0.5;
			betta = 0.5;

			%setting the new parameters
			newGroupI  = chosen(c);
			newGroupJ  = individual.numClusters+1;
			mixCoefI   = mixCoefL * alpha;
			mixCoefJ   = mixCoefL * (1-alpha);
			meanI      = meanL - sqrt( mixCoefJ/mixCoefI ) * u * a;
			meanJ      = meanL + sqrt( mixCoefI/mixCoefJ ) * u * a;
			aat        = a'*a;
			covI       = (mixCoefJ/mixCoefI) * covL + ( betta - betta * u^2 - 1 ) ...
						* (mixCoefL/mixCoefI) * aat + aat;			
			covJ       = (mixCoefI/mixCoefJ) * covL + ( betta * u^2 - betta - u^2 ) ...
						* (mixCoefL/mixCoefJ) * aat + aat;

			if DEBUG
				covs(:,:,1) = covI;
				covs(:,:,2) = covJ;
				%figure;
				%title('SPLIT'); hold all;
				%plot(data(:,1),data(:,2),'.'); 
				%plotGMM( meanL' , covL, [ .3 .3 .3 ], 1);
				%plotGMM([ meanI' meanJ'], covs, [ 0 .8 0 ], 1);
			end

%			fprintf('\nantes')
%			info_individual(individual)

			%updating individual
			individual.numClusters = individual.numClusters+1;
			individual.mean(newGroupI,:) = meanI;
			individual.mean(newGroupJ,:) = meanJ;
			individual.covariance(newGroupI,:) = squareformSymmetric( covI );
			individual.covariance(newGroupJ,:) = squareformSymmetric( covJ );
			individual.mixCoef(newGroupI) = mixCoefI;
			individual.mixCoef(newGroupJ) = mixCoefJ;

%			fprintf('\ndps')
%			info_individual(individual)
		end
	case 'var' %Variance-based Splitting

		z = randi([1 individual.numClusters]);
		%pick the clusters that will be mutated
		chosen = roulette_without_reposition( pMutationClusters, z );
		opts = statset('MaxIter',maxKMSIter);
		[vals idxClustResp] = max(posterior, [], 2);
		for c=1:z
			if ((individual.numClusters+1) > maxClusters)
				break;
			end

			if( sum(idxClustResp == chosen(c)) < 2 )
				%the gaussian represents few points.. do not split it
				continue;
			end
			%l is the cluster being splitted
			%it gives origin to clusters i and j 
			covL     = squareformSymmetric(individual.covariance( chosen(c), : ));
			meanL    = individual.mean( chosen(c),: );
			mixCoefL = individual.mixCoef( chosen(c) );

			%pick the feature used to break the ellipse
			sumVars = trace( covL );
			probs = diag(covL) ./ sumVars;
			featureSplit = roulette( probs, 1);
			d = covL( :, featureSplit );					
		
			%setting the new parameters
			meanI      = meanL + d';
			meanJ      = meanL - d';

			%run kmeans considering only objects that were probably generated by the old L gaussian
			objsInClusterL = find(idxClustResp == chosen(c));
			[labels centroids] = kmeans( data( objsInClusterL,: ), 2, 'Start', [ meanI; meanJ ],...
					'EmptyAction','singleton' ,'Options', opts ); 

            numFeatures = size(data,2);
			%the duplicate is because of the case nObjInCluster=1
			covI = cov([data(objsInClusterL(labels==1),:); data(objsInClusterL(labels==1),:)]);
			covJ = cov([data(objsInClusterL(labels==2),:); data(objsInClusterL(labels==2),:)]);
			%avoid numerical problems
			covI = covI + diag(ones(numFeatures,1)*1e-3);
			mixCoefI = mean(labels==1) * mixCoefL;
			mixCoefJ = mean(labels==2) * mixCoefL;

			newGroupI  = chosen(c);
			newGroupJ  = individual.numClusters+1;
			meanI      = centroids(1,:);
			meanJ      = centroids(2,:);

			if DEBUG
%				covs(:,:,1) = covI;
%				covs(:,:,2) = covJ;
%				f=figure;
%				title('SPLIT'); hold all;
%				plot(data(:,1),data(:,2),'.'); 
%				plotGMM( meanL' , covL, [ .3 .3 .3 ], 1);
%				plotGMM([ meanI' meanJ'], covs, [ 0 .8 0 ], 1);
%				hold off;
%				[tmp d] = system('date +%s');
%				print(f, '-depsc2', sprintf('figs/rand%d_%d_%d.eps', newGroupI, newGroupJ, mod(str2num(d),100000)));
%				close(f);
			end


			%updating individual
			individual.numClusters = individual.numClusters+1;
			individual.mean(newGroupI,:) = meanI;
			individual.mean(newGroupJ,:) = meanJ;
			individual.covariance(newGroupI,:) = squareformSymmetric( covI );
			individual.covariance(newGroupJ,:) = squareformSymmetric( covJ );
			individual.mixCoef(newGroupI) = mixCoefI;
			individual.mixCoef(newGroupJ) = mixCoefJ;

		end

end

end
